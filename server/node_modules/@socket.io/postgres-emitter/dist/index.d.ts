import type { DefaultEventsMap, EventNames, EventParams, EventsMap, TypedEventBroadcaster } from "./typed-events";
interface BroadcastFlags {
    volatile?: boolean;
    compress?: boolean;
}
export interface PostgresEmitterOptions {
    /**
     * The prefix of the notification channel
     * @default "socket.io"
     */
    channelPrefix: string;
    /**
     * The name of the table for payloads over the 8000 bytes limit or containing binary data
     */
    tableName: string;
    /**
     * The threshold for the payload size in bytes (see https://www.postgresql.org/docs/current/sql-notify.html)
     * @default 8000
     */
    payloadThreshold: number;
}
export declare class Emitter<EmitEvents extends EventsMap = DefaultEventsMap, ServerSideEvents extends EventsMap = DefaultEventsMap> {
    readonly pool: any;
    readonly nsp: string;
    readonly channel: string;
    readonly tableName: string;
    payloadThreshold: number;
    constructor(pool: any, nsp?: string, opts?: Partial<PostgresEmitterOptions>);
    /**
     * Return a new emitter for the given namespace.
     *
     * @param nsp - namespace
     * @public
     */
    of(nsp: string): Emitter;
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */
    emit<Ev extends EventNames<EmitEvents>>(ev: Ev, ...args: EventParams<EmitEvents, Ev>): true;
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    to(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    in(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return BroadcastOperator
     * @public
     */
    except(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return BroadcastOperator
     * @public
     */
    get volatile(): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return BroadcastOperator
     * @public
     */
    compress(compress: boolean): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsJoin(rooms: string | string[]): void;
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsLeave(rooms: string | string[]): void;
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */
    disconnectSockets(close?: boolean): void;
    /**
     * Send a packet to the Socket.IO servers in the cluster
     *
     * @param ev - the event name
     * @param args - any number of serializable arguments
     */
    serverSideEmit<Ev extends EventNames<ServerSideEvents>>(ev: Ev, ...args: EventParams<ServerSideEvents, Ev>): void;
}
export declare const RESERVED_EVENTS: ReadonlySet<string | Symbol>;
export declare class BroadcastOperator<EmitEvents extends EventsMap, ServerSideEvents extends EventsMap> implements TypedEventBroadcaster<EmitEvents> {
    private readonly emitter;
    private readonly rooms;
    private readonly exceptRooms;
    private readonly flags;
    constructor(emitter: Emitter, rooms?: Set<string>, exceptRooms?: Set<string>, flags?: BroadcastFlags);
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    to(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    in(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */
    except(room: string | string[]): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     * @public
     */
    compress(compress: boolean): BroadcastOperator<EmitEvents, ServerSideEvents>;
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return a new BroadcastOperator instance
     * @public
     */
    get volatile(): BroadcastOperator<EmitEvents, ServerSideEvents>;
    private publish;
    private publishWithAttachment;
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */
    emit<Ev extends EventNames<EmitEvents>>(ev: Ev, ...args: EventParams<EmitEvents, Ev>): true;
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsJoin(rooms: string | string[]): void;
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param rooms
     * @public
     */
    socketsLeave(rooms: string | string[]): void;
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */
    disconnectSockets(close?: boolean): void;
    /**
     * Send a packet to the Socket.IO servers in the cluster
     *
     * @param ev - the event name
     * @param args - any number of serializable arguments
     */
    serverSideEmit<Ev extends EventNames<ServerSideEvents>>(ev: Ev, ...args: EventParams<ServerSideEvents, Ev>): void;
}
export {};
